---
title:  "스프링 MVC 공부하기[15]"
excerpt: "예외처리 - 서블릿 예외 처리, response.sendError,오류 페이지"
date:   2021-10-18 00:01:00
header:
  teaser: /assets/images/spring.png

categories: MVC
tags:
  - Java
  - Spring
  - MVC
last_modified_at: 2021-10-18T00:01:00





---

<br/>

[스프링 MVC 2편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2/dashboard)를 보고 공부하고 정리한 내용을 올립니다

<br/>

## 💡 서블릿 예외 처리

스프링이 아닌 순수 서블릿 컨테이너는 예외를 어떻게 처리하는지 알아보겠다.

<br/>

#### 🚫 서블릿의 예외 처리

- ##### Exception(예외) : NullPointException 등 우리가 흔하게 보는 그런 예외

- ##### response.sendError (HTTP 상태 코드, 오류 메시지)

<br/>

<br/>

#### ✏ Exception 

#### 자바 직접 실행

**자바의 메인 메서드를 직접 실행하는 경우 main이라는 이름의 쓰레드가 실행된다.**

**실행 도중에 예외를 잡지 못하고 처음 실행한 main() 메서드를 넘어서 예외가 던져지면 예외 정보를 남기고 해당 쓰레드는 종료된다.**

##### <br/>

#### 웹 애플리케이션

**웹 애플리케이션은 사용자 요청별로 별도의 쓰레드가 할당되고, 서블릿 컨테이너 안에서 실행된다.**

**애플리케이션에서 예외가 발생했는데, 어디선가 try- catch로 예외를 잡아서 처리하면 아무런 문제가 없다. 그런데 만약에 애플리케이션에서 예외를 잡지 못하고,  서블릿 밖으로까지 예외가 전달되면 어떻게 동작할까?**

<br/>

> **WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러 (예외발생)**

**결국 톰켓같은 WAS까지 예외가 전달된다. WAS는 예외가 올라오면 어떻게 처리해야 할까?**

**먼저 스프링 부트가 제공하는 기본 예외 페이지가 있는데 이건 꺼두자.**

<br/>

##### application.properties

`server.error.whitelable.enabled=false`

<br/>

<script src="https://gist.github.com/ShinDongHun1/737331a93d4322518599ae8ee1db16f5.js"></script>

다음 코드를 실행시켜보자.

![image-20211017222209796](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20211017222209796.png)

Exception의 경우 서버 내부에서 처리할 수 없는 오류가 발생한 것으로 생각해서 HTTP 상태 코드 500을 반환한다.

<br/>

<br/>

#### ✏ response.sendError(HTTP 상태 코드, 오류 메세지)

오류가 발생했을 때 HttpServletResponse가 제공하는 sendError 메서드를 사용해도 된다. 이것을 호출한다고 당장 예외가 발생하는 것은 아니지만, 서블릿 컨테이너에게 오류가 발생했다는 점을 전달할 수 있다.

- response.sendError(HTTP 상태 코드)
- response.sendError(HTTP 상태 코드, 오류 메시지)

<br/>

#### ServletExController 추가

<script src="https://gist.github.com/ShinDongHun1/e59d0e59200bb2656211701a21319869.js"></script>

<br/>

##### sendError 흐름 

> WAS (sendError  호출 기록 확인) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(response.sendError())

##### response.sendError를 호출하면 response 내부에 오류가 발생되었다는 상태를 저장해둔다.

##### 그리고 서블릿 컨테이너는 고객에게 응답 전에 response에 sendError()가 호출되었는지 확인한다.

##### 그리고 호출되었다면 설정한 오류 코드에 맞추어 기본 오류 페이지를 보여준다.

##### <br/>

##### 정리

서블릿 컨테이너가 제공하는 기본 예외 처리 화면은 사용자가 보기에 불편하다. 의미 있는 오류 화면을 제공해보자.

<br/>

<br/>

## 💡 서블릿 예외 처리 - 오류 화면 제공

서블릿은 Exception이 발생해서 서블릿 밖으로 전달되거나 또는 response.sendError()가 호출되었을 때 각각의 상황에 맞춘 오류 처리 기능을 제공한다.

<br/>

과거에는 web.xml 이라는 파일에 오류 화면을 등록했으나, 지금은 스프링 부트를 통해서 서블릿 컨테이너를 실행하기 때문에, 스프링 부트가 제공하는 기능을 사용해서 서블릿 오류 페이지를 등록하면 된다.

<br/>

##### 서블릿 오류 페이지 등록

<script src="https://gist.github.com/ShinDongHun1/61b2fdd385fbfc2c1a70e91ed21b97c3.js"></script>

<br/>

##### 오류를 처리할 컨트롤러

<script src="https://gist.github.com/ShinDongHun1/a4834ddf248d078d474edd95d82fd27c.js"></script>

<br/>

<br/>

## 💡 서블릿 예외 처리 - 오류 페이지 작동 원리

서블릿은 Exception이 발생해서 서블릿 밖으로 전달되거나 또는 response.sendError()가 호출되었을 때 설정된 오류 페이지를 찾는다.

##### 예외 발생 흐름

> WAS(여기까지 전파) <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)

##### sendError 흐름

> WAS(sendError 호출 기록 확인 )  <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(response.sendError)

<br/>

##### WAS는 해당 예외를 처리하는 오류 페이지 정보를 확인한다.

new ErrorPage(RuntimeException.class, "/error-page/500")

<br/>

예를 들어서 RuntimeException예외가 WAS 까지 전달되면, WAS는 오류 페이지 정보를 확인한다.

확인해보니  RuntimeException의 오류 페이지로 "/error-page/500"이 지정되어 있다.

WAS는 오류 페이지를 출력하기 위해 "/error-page/500"을 다시 요청한다

<br/>

##### 오류 페이지 요청 흐름 

> ##### WAS "/error-page/500" 다시 요청 -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러("/error-page/500") -> View 

<br/>

##### 중요한 점은 웹 브라우저(클라이언트)는 서버 내부에서 이런 일이 일어나는지 모른다는 것이다. 오직 서버 내부에서 오류 페이지를 찾기 위해 추가적인 호출을 한다.

<br/>

#### 정리

1. ##### 예외가 발생해서 WAS까지 전파한다

2. ##### WAS는 오류 페이지 경로를 찾아서 내부에서 오류 페이지를 호출한다. <span style="color:orange">이때 오류 페이지 경로로 필터, 서블릿, 인터셉터, 컨트롤러가 모두 다시 호출</span>된다.

<br/>

<br/>

### ✏ 오류 정보 추가

WAS는 오류 페이지를 단순히 다시 요청만 하는 것이 아니라, 오류 정보를 request의 attribute에 추가해서 넘겨준다. 필요하면 오류 페이지에서 이렇게 전달된 오류 정보를 사용할 수 있다.

<script src="https://gist.github.com/ShinDongHun1/8f86e731bfd30ebf1d5cb3340949cba6.js"></script>



