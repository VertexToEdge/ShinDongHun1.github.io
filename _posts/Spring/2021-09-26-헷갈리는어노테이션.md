---
title:  "Spring 어노테이션 정리"
excerpt: "진짜 존나어렵네"
date:   2021-09-26 19:16:00 +0900
header:
  teaser: /assets/images/spring.png

categories: javaSpring
tags:
  - Java
  - Spring
  - 
last_modified_at: 2021-09-26T19:16:00-05:00


---

### <br/>

<br/>

## 💡<span style = "color:orange"> @Configuration</span>

#### 구성(설정) 정보에 적용한다.  

#### 얘를 사용하면 가시적으로 설정파일이야~, Bean 등록할거야~ 라는것을 알 수 있다.

##### 이게 무슨 소리냐 하면, Autowired를 통해 자동으로 의존관계를 주입받는다면, OCP와 DIP를 지키기 위해, 인터페이스에 구현체를 자동 주입받는 방식을 사용할 것인데, 이러면 구현체로 뭐가 들어오는지 확인하기 위해서는 개발자가 직접 파일을 뒤져가며 찾아봐야 하는 수고로움이 있다.

##### 이것이 컴포넌트 스캔의 단점이다! 그래서 가시적으로 보여주기 위해 @Configuration을 사용하는 것.

<script src="https://gist.github.com/ShinDongHun1/4a8dc486e83244691f231d6109e8915a.js"></script>

이 코드를 보면 MemberRepository의 구현체로 무엇이 들어올지 알 수 없는 상황이다. 

두 가지 방법을 써보겠다. 

<script src="https://gist.github.com/ShinDongHun1/a7b9b06437b0fa22b14f049f74822af8.js"></script>

위 MemberRepository 설정정보와, (참고로 원래 H2MemberRepository에만 @Repository가 붙어있었는데, 이를 지워줘야 한다.  안지우면 똑같은 이름의 빈이 2개 등록됨으로 오류가 발생한다.)

<script src="https://gist.github.com/ShinDongHun1/96a7052a762e9bb00634cc87383692d4.js"></script>

이렇게 바꿔주면 h2MemberRepository가 들어오게 되는데,... 딱봐도 OCP를 지키지 못했다. h2가 아닌 MemoryMemberRepository를 사용하기 위해선 memoryMemberRepository로 이름을 바꿔주어야 하는데, 그럼 OCP 위반이다. 그렇다고 저 이름을 memberRepository같은것을 사용하기에는 들어올 수 있는 타입의 빈이 2개라 또 오류가 발생한다. 

해결방법이야..

<script src="https://gist.github.com/ShinDongHun1/87ae7d7b7baa313e0e520cf5a27a7f17.js"></script>

그냥 빈 하나를 지워버리면 해결된다. 이러면 MemberRepository로는 h2를 사용한다는것을 Config파일을 통해 가시적으로 바로 알 수 있기 때문에 위의 단점도 해결이다.

그럼 수동과 자동을 언제 써야 좋을까에 대한 고민이 있을텐데..

![image-20210926222339299](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20210926222339299.png)

![image-20210926222715981](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20210926222715981.png)

![image-20210926222727901](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20210926222727901.png)

이렇단다 ㅎㅎ

참고로

#### 컴포넌트 스캔 기본 대상 

#### 컴포넌트 스캔은 @Component 뿐만 아니라 다음과 내용도 추가로 대상에 포함한다. 

#### <span style = "color:orange">@Component</span> : 컴포넌트 스캔에서 사용

####  <span style = "color:orange">@Controlller</span> : 스프링 MVC 컨트롤러에서 사용 

#### <span style = "color:orange">@Service</span> : 스프링 비즈니스 로직에서 사용

####  <span style = "color:orange">@Repository</span> : 스프링 데이터 접근 계층에서 사용 

#### <span style = "color:orange">@Configuration</span> : 스프링 설정 정보에서 사용

<br/>

<br/>

<br/>

## 💡 <span style = "color:orange">@PersistenceContext</span>

#### jpa 를 할 때 순수 자바 환경에서는 엔티티 메니저를 직접 만들어서 넣어줬는데, 

#### 스프링이나 J2EE 컨테이너를 사용하면 컨테이너가 엔티티 매니저를 관리하고 제공해준다.

####  따라서 엔티티 매니저 팩토리에서 엔티티 매니저를 직접 생성해서 사용하는 것이 아닌, 컨테이너가 제공하는것을 사용해야 한다

#### @PersistenceContext가 컨테이너가 관리하는 엔티티 매니저를 주입하는 애노테이션이다

<br/>

<br/><br/>

## 상속관계 매핑

### 💡  <span style = "color:orange">@Inheritance</span> (strategy=InheritanceType.XXX)

- ##### JOINED

- ##### SINGLE_TABLE

- ##### TABLE_PER_CLASS

<br/>

### 💡 <span style = "color:orange">@DiscriminatorColumn</span>(name="DTYPE")

##### 부모 클래스에 선언한다. 하위 클래스를 구분하는 용도의 컬럼이다. 관례는 default = DTYPE

##### 하이버네이트의 조인 전략에서는 선언하지 않으면 DTYPE컬럼이 생성되지 않는다.

<br/>

### **💡 <span style = "color:orange">@DiscriminatorValue</span>("XXX")**

##### 하위 클래스에 선언한다. 엔티티를 저장할 때 슈퍼타입의 구분 컬럼에 저장할 값을 지정한다.

##### 어노테이션을 선언하지 않을 경우 기본값으로 클래스 이름이 들어간다.

<br/>

<br/>

## 💡<span style = "color:orange">@Enumerated</span>

Enum 타입 사용할때 사용, 속성으로 EnumType.STRING 필수!!

<br/>

<br/>

## 💡 <span style = "color:orange">@MappedSuperclass</span>

**DB에서는 각각의 테이블에 존재하지만 객체에서 공통 속성을 상속받고 싶은 경우**

**예를 들어 DB 의 모든 정보에는 등록된 시간과, 최근 수정시간이 들어가야 한다!**

**그래서 BaseEntity 클래스를 만들어 등록된 시간과, 최근 수정시간을 필드로 넣어줌.** 

**(그러나 데이터 베이스에는 BaseEntity란 테이블이 생성되지 않음!!!! 각각의 테이블에 등록된 시간과 최근 수정시간이라는 속성을 가졌음!!!! 즉 오로지 객체에서만 사용할 때!!!)**

**BaseEntity에 @MappedSuperclass 를 붙여주면 된다.**

**조회, 검색이 불가하며, BaseEntity는 직접 생성해서 사용할 일이 없으므로 추상 클래스를 권장한다.**

<br/>

<br/>

## 임베디드 타입

### 💡<span style = "color:orange">@Embeddable</span>

값 타입을 정의하는 곳에 표시

<br/>

<br/>

### 💡<span style = "color:orange">@Embedded</span>

값 타입을 사용하는 곳에 표시

<br/>

##### 임베디드 타입을 쓰던 안쓰던 테이블은 동일하다!!!

##### 자바에서 객체지향스럽게 코딩하기 위해 사용

<br/>

<br/>

## 임베디드 타입과 @MappedSuperclass 의 차이

#### 상속과 위임의 차이이다.

#### 상속은 말 그래도 extend를 하는 것, 위임은 다른 클래스의 객체를 멤버로 갖는 형태의 클래스 정의다.

#### <span style = "color:orange">임베디드 타입</span>은 <span style = "color:orange">위임</span>이며, 

#### <span style = "color:orange">@MappedSuperclass</span>는 <span style = "color:orange">상속</span>이다.

 

[임베디드 타입과 @MappedSuperclass 차이](https://www.inflearn.com/questions/18578)