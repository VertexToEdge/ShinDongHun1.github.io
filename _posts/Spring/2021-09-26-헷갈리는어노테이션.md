---
title:  "Spring 어노테이션 정리"
excerpt: "진짜 존나어렵네"
date:   2021-09-26 19:16:00 +0900
header:
  teaser: /assets/images/spring.png

categories: javaSpring
tags:
  - Java
  - Spring
  - 
last_modified_at: 2021-09-26T19:16:00-05:00


---

### <br/>

<br/>

## 💡<span style = "color:orange"> @Configuration</span>

#### 구성(설정) 정보에 적용한다.  

#### 얘를 사용하면 가시적으로 설정파일이야~, Bean 등록할거야~ 라는것을 알 수 있다.

<br/>

<br/>

## 💡 컴포넌트 스캔 기본 대상 

##### 컴포넌트 스캔은 @Component 뿐만 아니라 다음과 내용도 추가로 대상에 포함한다. 

- ##### <span style = "color:orange">@Component</span> : 컴포넌트 스캔에서 사용


- #####  <span style = "color:orange">@Controlller</span> : 스프링 MVC 컨트롤러에서 사용 


- ##### <span style = "color:orange">@Service</span> : 스프링 비즈니스 로직에서 사용


- #####  <span style = "color:orange">@Repository</span> : 스프링 데이터 접근 계층에서 사용 


- ##### <span style = "color:orange">@Configuration</span> : 스프링 설정 정보에서 사용


<br/>

<br/>

<br/>

## 💡 <span style = "color:orange">@PersistenceContext</span>

##### jpa 를 할 때 순수 자바 환경에서는 엔티티 메니저를 직접 만들어서 넣어줬는데, 

##### 스프링이나 J2EE 컨테이너를 사용하면 컨테이너가 엔티티 매니저를 관리하고 제공해준다.

#####  따라서 엔티티 매니저 팩토리에서 엔티티 매니저를 직접 생성해서 사용하는 것이 아닌, 컨테이너가 제공하는것을 사용해야 한다

##### @PersistenceContext가 컨테이너가 관리하는 엔티티 매니저를 주입하는 애노테이션이다

<br/><br/>

## 💡 <span style = "color:orange">@Quilifier , @Primary </span>

@Autowired로 의존관계를 자동 주입할 때 동일한 타입의 빈이 2 개 이상일 경우, 이를 해결하기 위해 사용.

[스프림 공부하기[6]](https://shindonghun1.github.io/javaspring/Spring-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0-6/)

<br/><br/>

## 상속관계 매핑

### 💡  <span style = "color:orange">@Inheritance</span> (strategy=InheritanceType.XXX)

- ##### JOINED

- ##### SINGLE_TABLE

- ##### TABLE_PER_CLASS

<br/>

### 💡 <span style = "color:orange">@DiscriminatorColumn</span>(name="DTYPE")

##### 부모 클래스에 선언한다. 하위 클래스를 구분하는 용도의 컬럼이다. 관례는 default = DTYPE

##### 하이버네이트의 조인 전략에서는 선언하지 않으면 DTYPE컬럼이 생성되지 않는다.

<br/>

### **💡 <span style = "color:orange">@DiscriminatorValue</span>("XXX")**

##### 하위 클래스에 선언한다. 엔티티를 저장할 때 슈퍼타입의 구분 컬럼에 저장할 값을 지정한다.

##### 어노테이션을 선언하지 않을 경우 기본값으로 클래스 이름이 들어간다.

<br/>

<br/>

## 💡<span style = "color:orange">@Enumerated</span>

Enum 타입 사용할때 사용, 속성으로 EnumType.STRING 필수!!

<br/>

<br/>

## 💡 <span style = "color:orange">@MappedSuperclass</span>

**DB에서는 각각의 테이블에 존재하지만 객체에서 공통 속성을 상속받고 싶은 경우**

**예를 들어 DB 의 모든 정보에는 등록된 시간과, 최근 수정시간이 들어가야 한다!**

**그래서 BaseEntity 클래스를 만들어 등록된 시간과, 최근 수정시간을 필드로 넣어줌.** 

**(그러나 데이터 베이스에는 BaseEntity란 테이블이 생성되지 않음!!!! 각각의 테이블에 등록된 시간과 최근 수정시간이라는 속성을 가졌음!!!! 즉 오로지 객체에서만 사용할 때!!!)**

**BaseEntity에 @MappedSuperclass 를 붙여주면 된다.**

**조회, 검색이 불가하며, BaseEntity는 직접 생성해서 사용할 일이 없으므로 추상 클래스를 권장한다.**

<br/>

<br/>

## 임베디드 타입

### 💡<span style = "color:orange">@Embeddable</span>

값 타입을 정의하는 곳에 표시

<br/>

<br/>

### 💡<span style = "color:orange">@Embedded</span>

값 타입을 사용하는 곳에 표시

<br/>

##### 임베디드 타입을 쓰던 안쓰던 테이블은 동일하다!!!

##### 자바에서 객체지향스럽게 코딩하기 위해 사용

<br/>

<br/>

## 임베디드 타입과 @MappedSuperclass 의 차이

#### 상속과 위임의 차이이다.

#### 상속은 말 그래도 extend를 하는 것, 위임은 다른 클래스의 객체를 멤버로 갖는 형태의 클래스 정의다.

#### <span style = "color:orange">임베디드 타입</span>은 <span style = "color:orange">위임</span>이며, 

#### <span style = "color:orange">@MappedSuperclass</span>는 <span style = "color:orange">상속</span>이다.

 

[임베디드 타입과 @MappedSuperclass 차이](https://www.inflearn.com/questions/18578)