---
title:  "Spring 어노테이션 정리"
excerpt: "진짜 존나어렵네"
date:   2021-09-26 19:16:00 +0900
header:
  teaser: /assets/images/spring.png

categories: javaSpring
tags:
  - Java
  - Spring
  - 
last_modified_at: 2021-09-26T19:16:00-05:00


---

### <br/>



## 💡 @Configuration

#### 구성(설정) 정보에 적용한다.  

#### 얘를 사용하면 가시적으로 설정파일이야~, Bean 등록할거야~ 라는것을 알 수 있다.

##### 이게 무슨 소리냐 하면, Autowired를 통해 자동으로 의존관계를 주입받는다면, OCP와 DIP를 지키기 위해, 인터페이스에 구현체를 자동 주입받는 방식을 사용할 것인데, 이러면 구현체로 뭐가 들어오는지 확인하기 위해서는 개발자가 직접 파일을 뒤져가며 찾아봐야 하는 수고로움이 있다.

##### 이것이 컴포넌트 스캔의 단점이다! 그래서 가시적으로 보여주기 위해 @Configuration을 사용하는 것.

<script src="https://gist.github.com/ShinDongHun1/4a8dc486e83244691f231d6109e8915a.js"></script>

이 코드를 보면 MemberRepository의 구현체로 무엇이 들어올지 알 수 없는 상황이다. 

두 가지 방법을 써보겠다. 

<script src="https://gist.github.com/ShinDongHun1/a7b9b06437b0fa22b14f049f74822af8.js"></script>

위 MemberRepository 설정정보와, (참고로 원래 H2MemberRepository에만 @Repository가 붙어있었는데, 이를 지워줘야 한다.  안지우면 똑같은 이름의 빈이 2개 등록됨으로 오류가 발생한다.)

<script src="https://gist.github.com/ShinDongHun1/96a7052a762e9bb00634cc87383692d4.js"></script>

이렇게 바꿔주면 h2MemberRepository가 들어오게 되는데,... 딱봐도 OCP를 지키지 못했다. h2가 아닌 MemoryMemberRepository를 사용하기 위해선 memoryMemberRepository로 이름을 바꿔주어야 하는데, 그럼 OCP 위반이다. 그렇다고 저 이름을 memberRepository같은것을 사용하기에는 들어올 수 있는 타입의 빈이 2개라 또 오류가 발생한다. 

해결방법이야..

<script src="https://gist.github.com/ShinDongHun1/87ae7d7b7baa313e0e520cf5a27a7f17.js"></script>

그냥 빈 하나를 지워버리면 해결된다. 이러면 MemberRepository로는 h2를 사용한다는것을 Config파일을 통해 가시적으로 바로 알 수 있기 때문에 위의 단점도 해결이다.

그럼 수동과 자동을 언제 써야 좋을까에 대한 고민이 있을텐데..

![image-20210926222339299](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20210926222339299.png)

![image-20210926222715981](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20210926222715981.png)

![image-20210926222727901](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20210926222727901.png)

이렇단다 ㅎㅎ

참고로

#### 컴포넌트 스캔 기본 대상 

#### 컴포넌트 스캔은 @Component 뿐만 아니라 다음과 내용도 추가로 대상에 포함한다. 

#### @Component : 컴포넌트 스캔에서 사용

####  @Controlller : 스프링 MVC 컨트롤러에서 사용 

#### @Service : 스프링 비즈니스 로직에서 사용

####  @Repository : 스프링 데이터 접근 계층에서 사용 

#### @Configuration : 스프링 설정 정보에서 사용







## 💡 @PersistenceContext

#### jpa 를 할 때 순수 자바 환경에서는 엔티티 메니저를 직접 만들어서 넣어줬는데, 

#### 스프링이나 J2EE 컨테이너를 사용하면 컨테이너가 엔티티 매니저를 관리하고 제공해준다.

####  따라서 엔티티 매니저 팩토리에서 엔티티 매니저를 직접 생성해서 사용하는 것이 아닌, 컨테이너가 제공하는것을 사용해야 한다

#### @PersistenceContext가 컨테이너가 관리하는 엔티티 매니저를 주입하는 애노테이션이다