---
title:  "값 타입과 임베디드 타입"
excerpt: "임베드디 타입"
date:   2021-10-22 22:07:00
header:
  teaser: /assets/images/spring.png

categories: JPA
tags:
  - Java
  - Spring
  - JPA
  - 임베디드 타입
last_modified_at: 2021-10-22T22:07:00

---

<br/>

## 💡 JPA의 데이터 타입 분류

##### JPA는 데이터 타입을 최상위 단계로 보았을 때 엔티티 타입과, 값 타입 두가지로 분류한다.

<br/>

### 엔티티 타입

- ##### @Entity로 정의하는 객체

- ##### 데이터가 변해도 식별자로 계속 추적이 가능(식별자는 변하지 않으므로)

<br/>

### 값 타입

- int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
- 식별자가 없고 값만 있으므로 변경시 추적이 불가능하다

<br/>

<br/>

## 💡 값 타입의 분류

##### 값 타입은 크게 기본값 타입, 임베디드 타입, 컬렉션 값 타입 3가지로 분류할 수 있다.

#### 기본값 타입

- 자바 기본 타입(int, double)
- 래퍼 클래스(Integer, Long)
- String

#### 임베디드 타입(embedded type, 복합 값 타입)

#### 컬렉션 값 타입(collection value type)

<br/>

<br/>

## 💡 기본 값 타입

##### 생명주기를 엔티티에 의존한다.

- 예를 들어 회원 엔티티가 있으면, 회원을 삭제하는 순간 String(name)과 int(age)와 같은 필드의 값들도 삭제가 된다.

##### <span style="color:red">값 타입은 절대로 공유하면 안된다.</span>

- 예를 들어 회원 이름을 변경하였을 때 다른 회원의 이름도 함께 변경되면 안된다.

<br/>

<br/>

## 💡 임베디드 타입(복합 값 타입)

##### 임베디드 타입이라는 것은(번역하면 내장 타입이라고도 불림) 새로운 값 타입을 직접 정의할 수 있다.

##### JPA는 임베디드 타입(embedded type)이라고 하며, 주로 기본 값 타입을 모아서 만들기 때문에 복합 값 타입이라고도 한다.

##### 중요한 점은 임베디드 타입도 int, String과 같은 값 타입이란 것이다.

<br/>

#### 예를 들어보자

##### 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소(도시, 번지, 우편번호)를 가진다.

- 시작일 종료일이 비슷해 보인다 => workPeriod로 묶자

- 도시, 번지, 우편번호를 묶어서 사용할 수 있을 것만 같다. => homeAddress로 묶자

##### Member

```java
@Entity
public class Member {
	@Id @GenerateValue
    private Long id;
    
    private String name;
    
    private Period workPeriod;
    
    private Address homeAddress;
}
```

<br/>

##### Period

```java
public class Period {

    private LocalDateTime startDate;
    
    private LocalDateTime endDate;
    
}
```

<br/>

##### Address

```java
public class Address {

    private String city;
    
    private String street;
    
    private String zipcode;
    
}
```

<br/>

### 임베디드 타입 사용법

##### @Embeddable : 값 타입을 정의하는 곳에 표시

##### @Embedded : 값 타입을 사용하는 곳에 표시

##### 기본 생성자 필수

<br/>

<br/>

### 임베디드 타입 장점

- ##### 재사용 가능

- ##### 높은 응집도

- ##### Period.isWork() 처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있다.

- ##### 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함

<br/>

<br/>

#### 임베디드 타입에서 중요한 것은, 객체가 임베디드 타입을 사용한다고 해도 테이블은 아무런 변경도 일어나지 않는다는 것이다.

<br/>

<br/>

### @Inheritance, @MappedSuperclass, @Embeddable ???

- ##### @Inheritance : 상속관계를 매핑할때 사용하며, 구현 전략에 따라 테이블이 바뀐다.

- ##### @MappedSuperclass : 공통 매핑 정보가 필요할 때 사용한다. 엔티티의 공통되는 속성들을 상속을 받아서 사용하고 싶을 때 사용한다. 즉 테이블은 변함이 없으나, 귀찮음을 해소하기 위한 방법

- ##### @Embeddable : 상속과 전혀 관련이 없다. @MappedSuperclass와 비슷하지만, @MappedSuperclass는 상속을 받아 사용하는거고, @Embeddable은 새로운 값 타입을 만들어서 사용하는 것이다.\

예를 들어 Address 클래스(필드로는 street와 zipcode가 있다고 하자)를 만들어 이를 상속받아 사용하는 HomeAddress와, CompanyAddress가 있고, 필드로 Address(private Address address)를 가지는 Member가 있다고 했을 때

HomeAddress와 CompanyAddress는 extends Address를 하기 때문에 @Inheritance를 해야하고, 

Member는 상속받는 것이 아니라 필드로서 사용하기 때문에 @Embedded를 사용해야 한다.

#### 간단하게 말하면 @MappedSuperclass와 임베디드 타입은 상속과 위임의 차이이다.

<br/>

<br/>

### @MappedSuperclass와 임베디드 타입을 언제 사용할까?

[https://www.inflearn.com/questions/18578](https://www.inflearn.com/questions/18578)

[https://www.inflearn.com/questions/145049](https://www.inflearn.com/questions/145049)

<br/>

### 임베디드 타입과 연관관계

임베디드 타입은 입베디드 타입을 필드로 가질 수 있으며

##### <span style="color:orange"> 엔티티도 가질 수 있다</span>

![image-20211022222814127](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20211022222814127.png)

##### 위의 예시에서 Member는 Address와 PhoneNumber란 임베디드 타입을 필드로 가지며,

- ##### Address는 필드로 Zipcode란 임베디드 타입을 가진다.

- ##### PhoneNumber는 필드로 PhoneEntity란 엔티티를 가진다.

<br/>

<br/>

### @AttributeOverride

##### 한 엔티티에서 같은 임베디드 타입을 사용한다면 어떻게 될까?

##### =>컬럼 명이 중복되어 오류가 발생한다.

#### 이럴때 @AttributeOverrides, @AttributeOverride를 사용해서 컬러 명 속성을 재정의 할 수 있다

```java
@Embeddable
public class Address {
	private String zipCode;
	private String address;
}
```



```java
@Embedded
@AttributeOverride(name = "zipCode", column = @Column(name = "home_zipCode"))
@AttributeOverride(name = "address", column = @Column(name = "home_address1"))
private Address homeAddress;


@Embedded
@AttributeOverrides({
    @AttributeOverride(name = "zipCode", column = @Column(name = "company_zipCode")),
@AttributeOverride(name = "address", column = @Column(name = "company_address1"))
})
private Address companyAddress;

```

<br/>

<br/>

<br/>

## 💡 값 타입과 불변 객체

##### 임베디드 타입 같은 값 타입은 여러 엔티티에서 공유가 가능하다.

![image-20211022223929730](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/image-20211022223929730.png)

##### 위와 같은 상황에서 OldCity를 NewCity로 변경하면 회원1과 회원2의 city가 모두 바뀐다.

##### 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하고, 따라서 값(인스턴스)를 복사해서 사용해야 한다.

##### 그러나 임베디드 타입은 자바의 객체 타입이므로, 참조 값을 직접 대입하는 것을 막을 방법이 없다.(즉 개발자가 실수로 값을 복사하지 않고, 실제 인스턴스의 값을 대입하는 것을 막을 방법이 없다)

<br/>

### 해결방안

#### 불변 객체

- ##### 객체 타입을 수정할 수 없게 만들면 부작용의 원천을 차단할 수 있다.

- ##### <span style="color:orange">값 타입은 불변 객체(immutable object)로 설계해야 한다</span>

- ##### 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체

- ##### <span style="color:orange">방법 : 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 된다.</span>

- ##### Integer, String은 자바가 제공하는 대표적인 불변 객체이다

그럼 값을 바꾸고 싶을 때는??? new 를 이용해서 새로운 객체를 만들어 넣어주면 된다!

<br/>

<br/>

### 📔 Reference

[인프런 - 자바 ORM 표준 JPA 프로그래밍](https://www.inflearn.com/course/ORM-JPA-Basic/dashboard)

[@MappedSuperclass와 임베디드 타입의 차이 - https://www.inflearn.com/questions/18578](https://www.inflearn.com/questions/18578)

[@MappedSuperclass와 임베디드 타입의 차이 - https://www.inflearn.com/questions/145049](https://www.inflearn.com/questions/145049)

[@AttributeOverride 사용법 - https://galid1.tistory.com/592](https://galid1.tistory.com/592)

