---
title:  "관계형 데이터베이스 공부하기 [1] - 관계형 모델"
excerpt: "관계형 모델"
date:   2021-09-28 20:16:00 +0900
header:
  teaser: 

categories: db
tags:
  - DB
  - RDB
  - 관계형 모델
last_modified_at: 2021-09-28T20:16:00-05:00




---

<br/>

<br/>

💡 관계형 데이터베이스 실전 입문(오큐노 미키야 지음, 성창규 옮김)이라는 책을 보고 정리한 내용들이다.

<br/>

<br/>

## 💡 SQL 과 관계형 모델

**SQL 은 <span style = "color:orange">관계형 데이터베이스(RDB)</span>에 질의를 하기 위한 언어**로, 여기서 중요한 것은 **관계형 데이터베이스가 대상**이라는 것이다.  따라서 SQL을 능숙하게 다루기 위해서는 관계형 모델에 대한 깊이있는 이해가 필요하다. 

<br/>

#### 💡 RDB는 관계형 모델을 바르게 구현할수록 진가를 발휘한다!

SQL은 **관계형 모델을 기반**으로 한 **질의 언어**이나, 관계형 모델을 **충실히 재현하지는 않는다.**  또한 유연성이 높에 설계된 언어이므로, 관계형 모델에 맞게 사용할 수도 있으나, 전혀 다르게 사용할 가능성도 있다. 후자의 경우를 방지하기 위해, 관계형 모델에 대한 이해가 필요하다.

<br/>

### 💡 관계형 모델

관계형 모델은 **실제 세계의 데이터**를 **<span style = "color:orange">[관계]</span>** 라는 개념을 사용해 **표현**한 **데이터 모델**이다.

여기서의 **모델**은 설계를 의미하는 모델링이 아닌, **<span style = "color:orange">"데이터를 어떻게 표현할까"</span>**라는 개념의 의미이다.

이러한 관계형 모델을 이해하는 데 가장 중요한 개념이 **<span style = "color:orange">릴레이션(관계)</span>** 이다.

(참고로 몽고디비는 데이터 모델로써 KVS(Key-Value-Store)를 사용하는데, 따라서 몽고디비에는 SQL을 사용하지 않는다.)

<br/>

### 💡 릴레이션

우선 SQL에서의 테이블에 대응하는 것이, 관계형 모델에서의 릴레이션이다.

릴레이션의 정의는 다음과 간다.

##### 릴레이션은 제목(Heading)과 본체(Body)로 구성되어 있다.

##### 제목

- 속성(Attribute)이 n개 모인 집합.
  - 속성은 이름과, 데이터 형으로 이루어짐
  - 속성은 SQL의 Column(열)과 대응

##### 본체

- 속성값의 집합인 행(== 튜플(tuple)의 집합)
  - 속성값의 집합(==튜플)은 SQL의 Row(행)과 대응



![릴레이션이란](https://raw.githubusercontent.com/ShinDongHun1/image_repo/main/img/%EB%A6%B4%EB%A0%88%EC%9D%B4%EC%85%98%EC%9D%B4%EB%9E%80.jpg)

혼자 나름 공부하며 정리하며 그려보았다. 

| 관계형 모델     | SQL          |
| --------------- | ------------ |
| 릴레이션        | 테이블       |
| 튜플(tuple)     | 행(row)      |
| 속성(Attribute) | 칼럼(Column) |

<br/>

## 💡 릴레이션의 연산

지금까지 릴레이션에 대해서 공부해 보았는데, 단순하게 릴레이션으로 데이터를 표현하는 것만으로는 큰 도움이 되지 않는다.

데이터는 그에 대한 연산(또는 조작)과 세트로 사용될 때 의미가 있다.

관계형 모델에서 데이터를 릴레이션이라고 표현한다면, 그에 대한 연산은 쿼리(질의)이다.

##### 즉 객체지향에서의 <span style = "color:orange">객체</span>에 대한 <span style = "color:orange">연산</span>은

##### 관계형 모델에서의 <span style = "color:orange">릴레이션</span>에 대한 <span style = "color:orange">쿼리</span>로 대응된다.

<br/>

#### 릴레이션의 연산

- **제한(Restrict)**
- **프로젝션(Projection)**
- **확장(Extend)**
- **속성명 변경(Rename)**
- **합집합(Union)**
- **교집합(Intersect)**
- **차집합(Difference)**
- **곱집합(Product)**
- **결합(Join)**

<br/>

#### ✏️ 제한(Restrict)

어떤 릴레이션들 중 특정 조건에 맞는 튜플을 포함한 릴레이션을 반환. 

결과는 원래 릴레이션의 부분집합이다.

<br/>

#### ✏️ 프로젝션(Projection)

릴레이션에서 특정 속성만 포함하는 릴레이션을 반환.

중복이 일어날 가능성이 있으며 중복이 일어난다면 같은 튜플로 간주된다.

결과는 원래의 릴레이션보다 속성이 줄어든다.

<br/>

#### ✏️ 확장(Extend)

프로젝션과 반대로 속성을 추가.

대부분 기존에 가지고 있던 속성값을 이용해 새로운 속성을 만들어낸다

(ex: 인구와 면적이라는 속성을 가진 릴레이션에서, 확장을 하면, 인구, 면적, 인구밀도(면적/인구)로 속성이 추가)

<br/>

#### ✏️ 속성명 변경(Rename)

말 그대로 단순히 속성명을 면경함. 주로 확장(Extend)한 속성에 대해 명칭을 부여할 때 사용

<br/>

#### ✏️ 합집합(Union)

두 개의 릴레이션에 포함된 모든 튜플로 구성된 릴레이션(합집합)을 반환.

이때 두 개의 릴레이션에서 공통되는 튜플이 있으면 중복값이 제거된 상태로 반환.

<br/>

#### ✏️ 교집합(Intersect)

두 개의 릴레이션에 모두 포함된(공통 부분) 릴레이션을 반환.

<br/>

#### ✏️ 차집합(Differencd)

두 개의 릴레이션에서 한쪽의 릴레이션에만 포함되어 있는 튜플로 구성된 릴레이션을 반환.

어느쪽의 릴레이션을 기준으로 정하는지에 따라 결과가 달라진다.

<br/>

#### ✏️ 곱집합(Product)

두 개의 릴레이션에 있는 튜플을 각각 조합한 릴레이션을 반환.

이때 릴레이션의 제목(속성(Attribute)이 n개 모인 집합)은 두 개의 릴레이션의 제목이 가진 속성을 모두 포함=> 즉 결과 릴레이션은 속성이 늘어난다.

<br/>

#### ✏️ 결합(Join)

공통된 속성을 가진 두 개의 릴레이션에서, 공통된 속성값이 같은 튜플끼리 조합한 릴레이션을 반환.

일치하는 값이 존재하지 않는 튜플은 결과에서 제외.

(우리가 흔히 아는 SQL에서의 내부조인(INNER JOIN)이다.)(난 SQL 공부 안해서 잘 몰라서 어제 공부함 ㅠㅠㅠㅠ)

[참고 - 조인 방법 정리](https://gent.tistory.com/376)

덧붙여서 교집합(Intersect)과 곱집합(Product)은 결합(Join)의 특수한 예의다.

곱집합 : 공통된 속성이 전혀 없는 두 개의 릴레이션의 결합

교집합: 모든 속성이 공통인 두 개의 릴레이션의 결합.

<br/>

<br/>

여기까지가 대표적인 릴레이션의 연산이며, 이것이 바로 쿼리의 본질이다. 이 원리를 응용하여 만들어진 것이 RDB이며, 따라서 RDB의 성능을 최대한 발휘하려면 이런 동작을 기반으로 SQL을 작성해야 한다.

<br/>

<br/>

### 💡 클로저(Closure)

릴레이션에 연산을 사용한 결과는 릴레이션이다.

즉 연산의 입력과 출력이 같으며, 이러한 성질을 가진 데이터 구조를 **클로저(폐쇠)**라는 성질을 가졌다고 한다. 

<br/>

<br/>

### 💡 도메인(domain)

(이부분은 솔직히 잘 이해가 되지 않는다. Spring이나 DDD(도메인 주도 설계)에서의 도메인과는 조금 의미가 다른 것 같다 ㅠㅠ)

컴퓨터 프로그렘에서 변수에 대입할 수 있는 값은 유한하며, **<span style = "color:orange">데이터 형식</span>**은 그 **<span style = "color:orange">변수에 대입</span>할 수 있는 값의 유한집합**이다.

그리고 관계형 모델에서 **데이터 형식**은 **<span style = "color:orange">도메인</span>**이라고 한다.

이제 릴레이션을 생각해 보자.

속성의 데이터 형식, 즉 도메인이 유한집합 이라는 것은, 튜플이 얻을 수 있는 값을, 도메인의 곱집합으로 나타낼 수 있다는 말이다.

(도메인은 데이터 형식이고, 데이터 형식은 변수에 대입할 수 있는 값의 유한집합 이므로, 도메인은 유한집합이다.)

(즉 만약 "이름"이라는 속성에서, 도메인은 "신동훈", "김유겸", ..과 같은 값의 유한집합이다.(무한할 것 같지만, 컴퓨터로는 무한한 값을 표현할 수 없기에 결국 유한하다.))

(정리하면, 하나의 속성(Attribute)에 대하여, 대입할 수 있는 값의 유한집합이 도메인이며, 속성과 1대1로 대응되며, 

만약 속성이 "이름" 과 "나이" 로 이루어진 릴레이션이라면, 그 릴레이션이 가질 수 있는 값은 "이름" 도메인과, "나이" 도메인의 곱집합에서 특정 튜플들을 선택하여 구성한 값이다.)

#### (일단 제가 공부하며 이해한 대로 정리해 봤어요. 혹시나 틀린 정보가 있다면 수정하겠습니다.)

<br/>

<br/>

### 💡 SELECT

SELECT의 기본형은 다음과 같다.

> **SELECT  컬럼의 목록**
>
> **FROM  테이블의 목록**
>
> **WHERE 검색 조건**

<br/>

#### 컬럼의 목록은  <span style = "color:orange">프로젝션</span>(Projection), 테이블의 목록은 <span style = "color:orange">곱집합(Product)</span>,  검색 조건은 <span style = "color:orange">제한(Restrict)</span>이다.

(저는 SQL을 잘 몰라서 왜 테이블의 목록이 곱집합이지 했는데,,, 'FROM 테이블1, 테이블2' 를 하면 테이블1 과 테이블2 의 곱집합이 생긴다네요! )



Select를 이해하는 데 있어 또 중요한 사실이 있는데, 바로 각 연산이 평가되는 순서이다. 위의 SELECT에서는 다음과 같은 순서로 평가된다.

1. 테이블의 목록
2. 검색 조건
3. 컬럼의 목록

<br/>

<br/>

### 💡 INSERT(삽입)

이어서 갱신 처리이다.(SELECT는 유일한 참조 명령으로, 나머지 DELETE, UPDATE등과 같은 명령은 다 갱신 명령이다.)

##### 사실 관계형 모델에는 갱신이라는 개념이 존재하지 않는다. 릴레이션은 <span style = "color:orange">값</span>이기 때문에 릴레이션을 갱신하는 것은 불가능하다.

예를 들어 int a =1; a=2; 를 수행했을 때,  1의 의미가 변화하는가? 변하지 않는다!

1처럼, 릴레이션은 값이다. 

그런데 SQL에서는 테이블 내의 값을 변경할 수 있다. 릴레이션이 값이라면, 그에 상응하는 테이블이 갱신된다는 것은 이상하다.

이와 같은 모순은 테이블이 **값과 변수라는 양쪽의 역할**을 하기 때문이다.

관계형 모델에서 릴레이션을 저장하는 변수를 RelVar(Relation Variable, 관계 변수)라고 한다. 

즉 SQL에서 테이블의 갱신 처리는 RelVar의 역할로 테이블에 할당된 릴레이션의 값을 변경하는 것이다.

그럼 Insert의 작업의 과정을 한번 보자

RelVar에 저장된 값(릴레이션)에 새롭게 INSERT할 튜플을 추가하고, RelVar에 새롭게 저장하는 작업에 해당한다.

RelVar을 R, 새롭게 삽입된 행에 대한 튜플을 T, 라고 했을 때, 합집합 U를 이용해 다음과 같이 나타낸다

R := R U { T }

({ T }는 튜플 T만 포함하는 릴레이션이다.)

<br/>

<br/>

### 💡 DELETE(삭제)

삽입을 이해했으면 삭제도 쉽게 이해할 수 있다.

R := R - {T}

더욱 직관적인 표현으로, DELETE는 RelVar을 WHERE절의 조건에 만족하지 않는 튜플로 이루어진 릴레이션으로 바꾸는 것과 같다,

<br/>

<br/>

### 💡 UPDATE(갱신)

1. 전체 릴레이션에서 WHERE절의 조건에 맞는 튜플로 이루어진 릴레이션의 차집합을 구한다.(그럼 조건에 맞지 않는 튜플들만 남게된다.)
2. 1의 결과로 나온 릴레이션(조건에 맞지 않는 튜플들만 남아있음)에 수정을 가한 릴레이션(SET을 수행한 릴레이션)의 합집합을 구한다.
3. 2의 합집합을 RelVar에 대입한다.

R := {R - {T1}} U {T2}

({ T1 }은 Where절에 조건에 해당하는 릴레이션, {T2}는 {T1}에 수정을 가한 릴레이션)

<br/>

<br/>

## 💡 SQL에는 있고 관계형 모델에는 없는 것

- #### 요소의 중복

- #### 요소 사이의 순서

- #### 릴레이션의 갱신

- #### 트랜잭션

- #### 스토어드 프로시저

- #### NULL

(트랜잭션은 후에 자세히 공부할 예정이다.)

(프로시저란 어떤 업무를 수행하기 위한 절차로서, 함수는 프로시저의 각 프로세스를 수행하기 위해 필요한 기술들이다. )

(집합에는 NULL의 개념이 없다. NULL은 값이 존재하지 않거나, 혹은 존재하는지 알 수 없다는 의미로서 값이 아니다.)

<br/>

<br/>

<br/>

#### 이렇게 관계형 모델에 대해서 알아보았다. 이 책에서는 SQL을 조금 공부하고 관계형 모델을 공부하는것이 좋을 것이라 하였는데... 나는 뭣도 모르고 그냥 SQL 공부해야지 하고 이 책을 산건데.. 놀라웠다. SQL만 공부해서는 알 수 없는 것들을 알게된 느낌이랄까..? 일단 엄청 어렵지만 열심히 해바야징.. 그리고 SQL 책도 샀다..ㅠ 공부해야징..

<br/>