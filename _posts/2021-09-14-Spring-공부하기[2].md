---
title:  "Spring 공부하기[2]"
excerpt: "영속성 컨텍스트 - [2], 플러시, 준영속에 대하여"


categories: javaSpring
tags:
  - Java
  - Spring
  - 영속성 컨텍스트
last_modified_at: 2021-09-14T15:08:00-05:00


---

<br/>

저번에는 영속성 컨텍스트의 개념과, 생명주기에 대해서 공부했는데용

계속해서 영속성 컨텍스트에 대해서 공부해봅시당.!

<br/>

<br/>

### 1. 영속성 컨텍스트의 이점

영속성 컨텍스트를 사용하면 크게 5가지 이점이 있는데용! 하나씩 살펴보도록 할게용!

우선 5가지 이점은

- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

이렇게 있는데 이름만 봐서는 감이 안잡히실거예용. 같이 하나씩 공부해보죠!

<br/>

<br/>

#### 1-1. 엔티티 조회, 1차 캐시

```
//엔티티를 생성한 상태(비영속)
Member member = new Member();
member.setId(1L);
member.setUsername("회원1")

//엔티티를 영속 => 1차 캐시에 저장됨
em.persist(member);

//데이터베이스가 아니라 1차 캐시에서 조회
Member findMember = em.find(Member.class, 1L);

//1차캐시에는 없고, 데이터베이스에는 존재하는 member2를 찾는다고 해보자
Member findMember2 = em.find(Member.class, 2L);

//위 코드를 실행하면, findMember2는 1차 캐시에 없으므로, DB에서 조회를 한 후, 
//조회한 객체를 1차캐시에 저장하고 반환하게 된다.

```

이렇게 1차 캐시를 통해, 값이 존재하면 **직접 DB까지 가지 않아도 값을 가져올 수 있는** 이점이 있으나..실제로는 그렇게까지 큰 도움이 되는것은 아니라고..ㅎㅎ 

(뒤에서 배울 내용이나, entityManager는 데이터베이스 트랜잭션 단위로 만들고(**트랜잭션과 entityManager가 1대1 대응**이라는 뜻 같아용), **트랜잭션이 끝나면 영속성 컨텍스트를 지우기 때문에**, 굉장히 짧은 순간에만 존재하게 되므로, 큰 이점이 되지는 않는다 )

<br/>

<br/>

#### 1-2. 영속 엔티티의 동일성 보장

```
Member a = em.find(Member.class, 1L);
Member b = em.find(Member.class, 1L);

//a == b ,동일성 비교의 값은 true 
```

1차 캐시로 **반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준**을 데이터베이스가 아닌 **애플리케이션 차원에서 제공**한다.

음... 난 아직 데이터베이스에 대해서는 잘 모르니까... 그냥 일단은 넘어가고, 다음번에 데이터 베이스 공부할 때 이곳을 수정하여, 링크를 달던지, 이것에 대해서 설명을 하도록 하겠다.

일단은 그냥 **같은 트랜잭션 안에서 == 비교를 하면 true가 나온다** 정도로만 생각하고 넘어가자!

<br/>

<br/>

#### 1-3. 엔티티 등록시 트랜잭션을 지원하는 쓰기 지연

```
EntityManager em = emf.createEntityManager();
EntityTransaction tx = em.getTransaction();
tx.begin();

em.persist(memberA);
em.persist(memberB);
//여기까지는 INSERT SQL을 데이터베이스에 날리지 않는다

//커밋하는 순간에 데이터베이스에 INSERT SQL을 보낸다.
tx.commit();
```

대충 persist를 통해 엔티티를 영속성 컨텍스트에 넣으면, INSERT SQL을 생성만 하고, **생성한 SQL을 쓰기 지연 SQL저장소**에 저장해둔다. 

여러개의 엔티티를 커밋하면, 쓰기 지연 SQL 저장소에는 여러 SQL이 들어있을 것이다.

이 보관된 SQL들이 바로 **commit하는 순간에 데이터베이스로 보내진다.**

<br/>

<br/>

#### 1-4. 변경 감지(Dirty Checking)

이게 참 재미있는 부분이다.

예시를 위해 다음과 같은 코드를 실행해 보겠다.

```
member1.setId(1L);
member1.setName("신동훈");
member2.setId(2L);
member2.setName("김유겸");

em.persist(member1);
em.persist(member2);

tx.commit();
```

다음 코드의 결과로는, 데이터베이스에 "신동훈"과 "김유겸"이 저장되어 있을 것이다.

<br/>

그런데 다음 코드를 보자

```
member1.setId(1L);
member1.setName("신동훈");
member2.setId(2L);
member2.setName("김유겸");

em.persist(member1);
em.persist(member2);

member1.setName("따거");//추가

tx.commit();
```

member1을 persist 해준 후 member1의 이름을 "신동훈"에서 "따거"로 바꿨다.

나는 단지 member1의 이름을 바꾸기만 했지, persist를 하거나 뭐 따로 해준것이 없는데..

놀랍게도 위 코드를 실행하면 데이터베이스에는 "신동훈"이 아니라, "따거"로 저장된다.

<br/>

심지어

```
Member member = em.find(Member.class,  1L);//member에는 "따거" ,1L이 들어감
member.setName("신");

tx.commit();
```

이렇게 데이터베이스에 저장된 값을 find로 찾아와서, 

찾아온 member의 이름을 "신" 으로 바꿔주고 commit하면???

놀랍게도 데이터베이스에는 이름이 "신"으로 저장된다.

<br/>

비밀이 무엇일까?

트랜잭션이 commit 될 때 엔티티랑 **스냅샷**을 비교한다.  스냅샷이 무엇인지 궁금할텐데,

1차 캐시 안에는 @Id, Entity, 스냅샷이란것이 존재한다. (@Id는 식별자이다. 아님 말고 ㅎ 난 그렇게 이해함. 아니라면 수정하겠습니다~)

스냅샷이란것은 "**값을 읽어온 최초 시점에 저장된 모습**"이라고 생각하면 좋을 것 같다.

아무튼 그래서 commit되는 시점에 엔티티랑 스냅샷을 비교해서, 스냅샷과 차이가 있다면, 그 부분을 감지해서 update쿼리를 "쓰기 지연 SQL 저장소"에 저장한 후 데이터베이스에 날리게 된다.

디게 신기하당 ㅎ.ㅎ

<br/>

<br/>

#### 1-5. 지연 로딩

이것은 아직 들어도 모를 것이다... 나중에 이것에 대해서 다루면, 링크를 걸어두겠다.

이것을 보고있는 당신들도 나와 같은 초보라면, 일단 그냥 넘어가도록 하자



<br/>

<br/>

#### 이렇게 해서 영속성 컨텍스트에 대해서 알아보았다! 

####  이제 다음에는 뭘 알아볼것이냐면!

<br/>

### 2. 플러시

플러시란 **영속성 컨텍스트의 변경내용을 데이터베이스에 반영**하는것이다.

플러시가 발생되는 순간에는 다음과 같은 일들이 발생한다(참고로 트랜잭션이 커밋되는 순간에 flush는 자동적으로 호출된다)

- 변경 감지
- 수정된 엔티티를 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

<br/>

#### 2-1. 영속성 컨텍스트를 플러시하는 방법

- em.flush() - 직접 호출 (직접 쓸 일을 거의 없지만 일단은 알아두면 좋다 ㅎ)
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

음.. 지금 당장은 알아도 큰 도움이 되는것은 아니니 일단 아~ 그렇구나~ 하고 이해만 넘어가도록 하자.

(내 판단 아님, 선생님께서 그러심;;;)

<br/>

**중요!!!!!**

**플러시를 한다고 해서 영속성 컨텍스트(1차캐시)가 비워지는것은 아니다!**

**영속성  컨텍스트는 그대로 유지**되며, 

변경 감지가 일어나고, 쓰기 지연 SQL 저장소에 Update에 쌓이고, 데이터베이스에 반영되는 과정이라고 보면 된다.

플러시라는 매커니즘이 동작할 수 있는 이유는 트랜잭션이라는 작업 단위가 있기에 가능한데, 커밋 직전에만 동기화를 해주면 되기 때문에.. 이러한 것들이 가능하다~ 라고 하네요 ㅎ.ㅎ....

<br/>

**참고**

 JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유

```
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

//중간에 JPQL 실행
query = em.createQuery("select m from Member m", Member.class);
List<member) members = query.getResultList();
```

다음과 같은 코드를 치게 되면, JPQL 실행 시점에 데이터베이스에서 등록된 Member들의 객체들 받아와야 하는데, 지금 persist만 상황이라 데이터베이스에는 반영이 안 된 상태이다. 

이러한 상황에서 DB에서 조회를 하게 되면 커다란 오류가 발생할 수 있으므로 이를 방지하기 위해 JPQL 실행 시점에 flush를 자동으로 호출하여서 데이터베이스에 반영되게 하는것이다.

<br/>

**참고의 참고**

JPQL 쿼리 실행시 플러시를 호출되게 하지 않으려면

```
em.setFlushMode(FlushModeType.COMMIT)
```

으로 해주면, 커밋할 때만 플러시가 되게 바꿀 수 있다.

(default 값은 FlushModeType.AUTO이다)

<br/>

<br/>

### 3. 준영속

저번에 준영속에 대해서 얘기했는데 또 얘기하는 이유는,, 위의 내용들을 알아야 이해할 수 있는 내용들에 대해서 다둘 것이기 때문이다.

<br/>

준영속 상태는 다시 말하면, 영속 상태의 엔티티가, 영속성 컨텍스트에서 분리되는 것인데

이렇게 되면 당연하게도 영속성 컨텍스트가 제공하는 기능을 사용할 수 없게된다.

(더티체킹이라던가 뭐 위에서 설명한 그런것들...)

<br/>

준영속 상태를 만드는 방법에는 3가지가 있다.

- em.detach(entity) - 특정 엔티티만 준영속 상태로 전환
- em.clear() - 영속성 컨텍스트를 완전히 초기화
- em.close() - 영송석 컨텍스트를 종료

<br/>

```
Member member = em.find(Member.class,541L);
em.detach(member); //혹은 em.clear();
Member member2 = em.find(Member.class,541L);

System.out.println(member == member2);
```

위 코드를 보자.

em.detach(member)가 빠졌다면, 동일성 보장 파트에서 배운 내용대로 true가 출력되야 했을 것이다.

그러나 detach 혹은 clear를 통해 **영속성 컨텍스트에서 member가 제외**되거나,

**영속성 컨텍스트 자체가 초기화** 되었다면

**둘의 동일성을 보장받을 수 없으므로** 위의 코드의 결과는 **false**가 나오게 된다. 

(참고로 em.close()를 하게되면 Session/EntityManager is closed 라는 오류가 발생한다)

<br/>

<br/>

<br/>

### 이렇게 해서 영속성과 관련된 내용들에 대해서 공부해보았다.. 아마 많이 어려울 것인데.. 열심히 공부하다보면 언젠간 익숙해지리라 생각하고... 다음 글은 아마 엔티티의 매핑에 대해서 공부하지 않을까 싶다.  스프링은 오늘도 참 재미있었다.
