---
title:  "템플릿 메서드 패턴"
excerpt: "템플릿 메서드 패턴"
date:   2021-11-06 18:00:00
header:
  teaser: /assets/images/spring.png

categories: GoF
tags:
  - GoF
last_modified_at: 2021-11-06T18:00:00

---

## 💡 템플릿 메서드 패턴

어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 **전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴**

<br/>

```java
@Slf4j
public abstract class AbstractTemplate {

    public void execute(){
        long start = System.currentTimeMillis();

        call();//하위 클래스에서 구현하여 사용

        long end = System.currentTimeMillis();
        long result = end - start;
        log.info("resultTime = {}",result);
    }

    protected abstract void call();
}
```

위와 같이 전체적은 구조는 바꾸지 않고 미리 지정해 둔 후, AbstractTemplate을 상속받은 하위 클래스에서 call을 구현하여 수행하는 내용을 지정할 수 있다.

<br/>

## 💡 템플릿 메서드 패턴의 목적

"작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다."-[GoF]

<br/>

## 💡 단점

템플릿 메서드 패턴은 결국 상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다.

따라서 상속에서 오는 단점들을 그대로 가지고 있다.

특히 **자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제**가 있다.

> 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이다. 하지만 두 가지 관점에서 걸계에 안 좋은 영향을 미친다. 하나는 상속이 캡슐화를 위반한다는 것이고, 다른 하나는 설계를 유현하지 못하게 만든다는 것이다. 
>
> 상속의 가장 큰 문제점은 캡슐화를 위반한다는 것이다. 상속을 이용하기 위해서는 부모 클래스의 내부 구조를 잘 알고 있어야 한다. 
>
> 결과적으로 부모 클래스의 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다. 캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다. 
>
> 상속의 두 번째 단점은 설계가 유연하지 않다는 것이다. 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 실행 시점에 객체의 종류를 변경하는 것이 불가능하다. 
>
> 
>
> ##### 위의 상속의 문제를 해결하기 위한 좋은 방법이 바로 합성(Composition이다)
>
> 
>
> ##### 출처 - 오브젝트(코드로 이해하는 객체지향 설계) 70p



<br/>

<br/>

## 📔 Reference

[템플릿 메서드 패턴이란](https://gmlwjd9405.github.io/2018/07/13/template-method-pattern.html)

[인프런 - 스프링 핵심 원리 고급편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8/dashboard)

##### 오브젝트(코드로 이해하는 객체지향 설계) 70p