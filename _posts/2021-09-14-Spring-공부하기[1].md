---
title:  "Spring 공부하기[1]"
excerpt: "영속성 컨텍스트 - [1]"
date:   2021-09-14 01:18:00 +0900


categories: javaSpring
tags:
  - Java
  - Spring
  - 영속성 컨텍스트


---

<br/>

난 지금 굉장이 화가난다.

글을 다 썼는데 저장을 잘못해서 다 날아가버렸다.

진짜 세상 참 치같다

<br/>

<br/>

### 1.  영속성 컨텍스트

영속성 컨텍스트를 알기 위해서는 **엔티티**라는 개념을 먼저 알아야 한다.

<br/>

#### 1-1. 엔티티(Entity)

구글에 찾아보니 엔티티란 실체, 객체라는 의미이다. (뭐라는겨 ;;;;)

그래서 또 찾아봤다. 

엔티티란 데이터의 집합을 의미한다.

엔티티란 쉽게 말해 실체, 객체라고 생각할 수 있다.

엔티티는 인스턴스들의 집합이라고 하였다. 

....

어쩌라는건지 잘 모르겠다. 

그래도 내가 가장 이해가 잘 되는 표현은 **엔티티는 인스턴스들의 집합**이다.

(참고로 **인스턴스**는 **객체를 소프트웨어 세계에 구현한 구체적인 실체** 라고 할 수 있다)(아님 말고 ㅎ, 난 그렇게 이해했음 ㅎ)

엔티티가 인스턴스들의 집합, 간단히 생각해서 인스턴스들이 들어있는 바구니라고 생각해보자. 그럼 안에 들어있는 인스턴스들을 구분하기 위해 논리적인 이름이 있어야 하는데, 이것을 **식별자**라고 부른다. 갑자기 식별자 이야기가 왜 나오냐면 이따 아래에서 **준영속**이란것을 공부할 때 알아두면 좋다.

<br/>

#### 1-2. 영속성 컨텍스트

다시 **영속성 컨텍스트**로 돌아와보자. 

그래서 영속성 컨텍스트란? "**엔티티를 영구 저장하는 환경**"이라는 뜻인데... 잘 이해가 안될것이다.

영속성 컨텍스트는 눈에 보이지 않는, **논리적인 개념**이며, **엔티티 매니저**(Entity manager)를 통해 영속성 컨텍스트에 접근한다.... 도 잘 이해가 안될것이다.

그래서 또 찾아보았다. 

**영속성 컨텍스트**는 쉽게 말해 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 **가상의 공간** 이라고 생각하면 쉬울 것 같다. 

<br/><br/><br/>

### 2. 엔티티의 생명주기

엔티티의 생명주기에는 4가지 상태가 있다.

- 비영속(new/transient)
- 영속(managed)
- 준영속(detached)
- 삭제(removed)

<br/>

하나씩 살펴보도록 하자

<br/>

#### 2-1. 비영속

말 그대로 영속되지 않은 상태이다. 예를 들어 우리가 Member 객체를 생성한다고 생각해보자.

```
Member member = new Member();

member.setId(1L);

member.setUsername("신동훈");
```

위 코드는 객체를 생성만 한 상태이고,  JPA와는 전혀 관계가 없다.

따라서 비영속 상태이다.

<br/>

<br/>

<br/>

#### 2-2. 영속

위 memeber 객체를 EntityManager를 통해 persist(member); 하게되면 영속성 컨텍스트에 관리되어지는

**영속 상태**가 된다. 난 이해 했는데 님들 이해 못했으면.. 나중에 내용을 좀 더 추가해보도록 하겠당.

<br/>

<br/>

<br/>

#### 2-3. 준영속

이부분이 살짝 어려웠다. 사실 개념만 보면 전혀 어렵지 않다.

우선 준영속 상태란 **영속성 컨텍스트에 저장되었다가 분리**된 상태이다.

다시말해 **영속성 컨텍스트에 저장이 된 경험이 있다**는것이 중요하다.

내가 조금 어려웠던 부분이, 그럼 준영속은 결국 비영속 상태와 같은 상태 아닌가?  왜 굳이 나눴나.. 궁금했었다.

준영속과 비영속 상태의 가장 큰 차이점은 **한번 영속상태가 된 적이 있는가 없는가**이다.

이것이 왜 중요하냐면, 처음 엔티티에 대해 설명할때 식별자란 것을 언급했었다.

영속상태가 되려면 **식별자가 반드시 존재**해야 한다. 그래서 **준영속 상태인 엔티티는 식별자가 무조건 존재**한다는것을 알 수 있다.

그러나 비영속 상태의 엔티티는 식별자가 존재하는지, 존재하지 않는지 알 수 없다. 

둘의 차이점이 이해되는가? (난 이해했으니 넘어가겠다.)

<br/>

<br/>

<br/>

#### 2-4. 삭제

난 바보임에 분명하다. 삭제와 준영속도 굉장히 헷갈렸다.

둘 다 영속성 컨텍스트에서 제거되는 거 같은데... 뭐가 다른걸까 싶어서 찾아봤다. 그런데 이게 웬일이람!

내 구글링 능력은 형편없었다. 뭐라는지도 모르겠고 그냥 못 찾았다! 

그래서 난 내 스스로 코드를 뚱땅뚱땅 쳐가며 분석해보았다.

우선 내 분석에 의한 결론은 다음과 같다.

- detach(entity); 는 해당 entity를 **영속성 컨텍스트**에서 제거한다.
- remove(entity); 는 해당 entity를 **영속성 컨텍스트에서 제거하며, 데이터 베이스에서도 제거**한다

<br/>

이거 알아보려고 다음과 같은 코드를 짰다.

<br/>

먼저 데이터베이스에 member1과 member2를 저장했다.

그 다음 em.find를 통해 member1과 member2를 불러왔다.

member1은 detach 시켰고, member2는 remove 시켰다.

commit 했다.

결과는 member1은 데이터베이스에 남아있었고,  member2는 데이터베이스에서 삭제되었다.

<br/>

따라서 **삭제** 상태는 **엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제**하는 것이라 이해하자!

<br/>

<br/>

<br/>

##### 오늘은 영속성 컨텍스트에 대해서 공부해 보았다. 사실 며칠전에 공부한건데 요새 통 몸이 안좋고 블로그 쓰는거 공부한다 뭐 한다 하다보니까.. 기억이 잘 나지도 않았고, 블로그도 열심히 써볼 겸 다시 강의 듣고 공부하면서 정리해가며 글을 썼다. 

<br/>

### 아직 영속성 컨텍스트에 대해서 다룰 내용이 남아가지구 다음 글에서 이어서 영속성 컨텍스트에 대해 알아가보겠다. 참고로 준영속 상태에 대해 조금 더 알아보려고 혼자 코드치다가 오류가 났는데, 왜 난건지 대체 이해가 안되서 알아보는 중이다. 알게된다면 이번 글을 수정하거나, 다음 글에서 다뤄보도록 하겠당.

<br/>

##### 진짜 글 다썼는데 저장 잘못한거 개킹받네;;;