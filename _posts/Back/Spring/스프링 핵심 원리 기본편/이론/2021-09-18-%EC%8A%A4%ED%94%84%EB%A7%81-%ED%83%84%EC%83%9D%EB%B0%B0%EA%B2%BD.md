---
title:  "[Spring] 스프링이란?"
excerpt: "스프링의 탄생 배경과, 스프링에 대하여"
date:   2021-09-18 01:18:00 
header:
  teaser: /assets/images/spring.png

categories: javaSpring
tags:
  - Java
  - Spring
last_modified_at: 2021-12-04T01:18:00


---

<br/>

## 스프링이 왜 탄생하였나

### EJB(Enterprise Java Bean)

EJB를 검색해보면 다음과 같이 설명한다.

> **엔터프라이즈 자바빈즈**(Enterprise JavaBeans; **EJB**)는 기업환경의 시스템을 구현하기 위한 [서버](https://ko.wikipedia.org/wiki/서버)측 [컴포넌트](https://ko.wikipedia.org/wiki/컴포넌트) 모델이다. 즉, EJB는 애플리케이션의 업무 로직을 가지고 있는 서버 애플리케이션이다.
>
> [위키백과 - 엔터프라이즈 자바빈즈](https://ko.wikipedia.org/wiki/%EC%97%94%ED%84%B0%ED%94%84%EB%9D%BC%EC%9D%B4%EC%A6%88_%EC%9E%90%EB%B0%94%EB%B9%88%EC%A6%88)

우선 Java bean이란 **자바 객체를 재사용 하능하게  컴포넌트화** 시킬 수 있는 코딩 방침을 정의한 것을 의미한다.

즉 위에서 설명하는 EJB는 "**컴포넌트(빈 혹은 객체)들을 관리하는 컨테이너**"라고 가볍게 이해할 수 있다.

<br/>

### EJB의 문제점

EJB는 보안, 트랜잭션, 분산 컴퓨팅 등 많은 서비스를 제공하였으나, 이를 위해서는 EJB 스펙을 지켜야 했으며, 결국 서비스가 구현해야 하는 실제 비즈니스 로직보다 EJB 컨테이너를 사용하기 위한 코드들이 많아지는 결과를 발생시켰다.

##### 이러한 문제의 원인은 비즈니스 로직에 특정 기술(EJB)이 종속되어 있다는 것이었다. 

컨테이너의 목적은 객체가 필요할 때 마다 컨테이너에서 받아내는 방식을 통해 객체들간의 의존성을 해결하는 것이었다.

스프링 창시자인 로드 존슨은 EJB를 사용하지 않고도 객체간 의존성 해결이 가능한 컨테이너를 개발했는데, 이것이 스프링의 시작이었다.

##### 즉 <span style="color:orange">특정 기술에 종속되지 않고 객체를 관리할 수 있는 컨테이너를 제공</span>하는 것이 스프링의 기본 철학이다.

<br/>

<br/>

## Spring ?

##### 스프링은 '특정한 하나'를 지칭하는 것이 아닌 '여러 기술들의 집합체'이다.

- **스프링 프레임워크** (핵심)
- **스프링부트** (스프링 프레임워크의 모든 기술들을 편리하게 사용할 수 있도록 도와준다.)
- 스프링 데이터 (CRUD를 편리하게)
- 스프링 시큐리티 (보안 관련 기능을 편리하게)
- 스프링 세션(세션 기능을 편리하게)
- 스프링 Rest Docs (api문서를 편리하게)
- 스프링 배치 (배치처리에 특화)

필자는 처음 스프링을 공부할 때 "스프링 프레임워크랑 스프링 부트가 다른건가? 뭐가 다른거지? 뭘 공부해야 하는거지?" 하면서 많은 고민을 했었다. 

##### 스프링 프레임워크가 가장 핵심이다. 

스프링의 모든 기술들은 스프링 프레임워크 속에서 작동한다.

##### 그리고 스프링 프레임워크를 포함한 스프링의 여러 기술들(시큐리티, 데이터, 세션, ...)을 편리하게 사용할 수 있게 도와주는 기술이 바로 스프링 부트이다.

##### 기존에 스프링 프레임워크가 기본적으로 해야할 셋팅이 너무 많고 어려웠기에, 이를 해소하기 위해 스프링 부트가 등장했다.

<br/>

<br/>

## Spring Framework

##### 스프링 프레임워크의 기술

- 핵심 기술: 스프링 DI 컨테이너,  AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM지원, XML지원
- 기술 통합: 캐시, 이메일, 원격접근 스케줄링
- 테스트

<br/>

<br/>

## 스프링 부트

##### 스프링 프레임워크 기반 프로젝트를 복잡한 설정없이 쉽고 빠르게 만들어주는 프레임워크이다.

- **스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용**
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨.
- 손쉬운 빌드 구성을 위한 starter 종속성 제공 (라이브러리를 땡겨올 때, 추가로 필요한 라이브러리들을 종속적으로 땡겨옴)
- 스프링과 3rd parth(외부) 라이브러리 자동 구성 
- 관례에 의한 간결한 설정 

스프링부트는 스프링 프레임워크랑 별도로 사용할 수 있는것이 아니다!

여러 스프링 프레임워크 기능들을 중간에서 편리하게 사용할 수 있게 기능을 제공해주는 것이다.

<br/>

<br/>

## 스프링의 핵심 개념

- 스프링은 **자바 언어 기반**의 프레임워크
- 자바 언어의 가장 큰 특징 -> <span style="color:Orange">**객체 지향 언어**</span>
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크

##### 스프링은 **<span style="color:Orange">좋은 객체 지향 애플리케이션을 개발</span>**할 수 있게 도와주는 <span style="color:Orange">**프레임워크**</span>이다.

스프링을 이해하기 위해서는 우선 객체 지향 프로그래밍에 대한 이해가 필요하다.

<br/>

<br/>

## 객체 지향 프로그래밍

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 "<span style="color:Orange">**객체**</span>"들의 **모임**으로 파악하고자 하는 것이다. 각각의 객체들은 메시지를 주고받고, 데이터를 처리할 수 있다(**협력**)
- 객체 지향 프로그래밍은 프로그램을 **유연**하고 <span style="color:Orange">**변경이 용이**</span>하게 만들어준다. (**<span style="color:Orange">다형성</span>**)

<br/>

<br/>

## 다형성

##### <span style="color:Orange">역할</span>(인터페이스)과 <span style="color:Orange">구현</span>(구현체)으로 다형성을 활용하자.

다형성을 활용하면

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.

- ##### 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

##### 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.

<br/>

<br/>

## SOLID - 좋은 객체 지향 설계의 5가지 원칙

- **SRP** : 단일 책임 원칙 (Single Responsibility Principle)
- **OCP** : 개방-폐쇠 원칙 (Open/Closed Principle)
- **LSP** : 리스코프 치환 원칙 (Liskov Substitution Principle)
- **ISP** : 인터페이스 분리 원칙 (Interface Segregation Principle)
- **DIP** : 의존관계 역전 원칙  (Dependency Inversion Principle)

<br/>

<br/>

### SRP 단일 책임 원칙

- ##### 한 클래스는 하나의 책임만 가져야 한다

하나의 책임이라는 것의 기준은 **<span style="color:Orange">변경</span>**. 변경이 있을 때 파급 효과가 적어야 단일 책임 원칙을 잘 따른 것.

<br/>

<br/>

### OCP 개방-폐쇄 원칙

- 소프트웨어 요소는 **확장에는 열려**있으나 **변경에는 닫혀**있어야 한다.
- **다형성**을 활용
- **인터페이스를 구현한 새로운 클래스**를 하나 만들어서 새로운 기능을 구현
- 역할과 구현의 분리를 생각하자.

##### 아래 코드를 보자.

```java
public class Member{    
	private Car myCar = new Benz();
}
```

```
public class Member{    
	//private Car myCar = new Benz();    
	private Car myCar = new Lexus();
}
```

##### 다형성을 활용하였음에도 불구하고 기존의 코드가 변경된다.

<br/>

####  OCP(개방-폐쇄 원칙)의 문제점

- **구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.**

- 분명 **다형성**을 사용했으나 OCP를 지킬 수 없다

- 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다 

##### 바로 이 문제점을 스프링 컨테이너가 해결해준다.

<br/>

<br/>

### LSP 리스코프 치환 원칙

- 프로그램의 객체는 **프로그램의 정확성**을 깨뜨리지 않으면서 **하위 타입의 인스턴스**로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 **인터페이스 규약을 다 지켜야 한다는 것**, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다

##### 예시) 

- 자동차 인터페이스의 엑셀 기능은 앞으로 가는 것인데, 이것을 뒤로 가게 구현하는것은 LSP를 위반한 것이다

<br/>

<br/>

### ISP 인터페이스 분리 원칙

- **특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다**
- 인터페이스가 명확해지고, 대체 가능성이 높아진다

<br/>

<br/>

### DIP 의존관계 역전 원칙

- 클라이언트 코드는 **인터페이스**만 바라보고, 의존해서 작성하라는 뜻
- 프로그래머는 "추상화에 의존해야지 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나.
- 역할에 의존하게 해야 한다는 뜻.

##### 아까 OCP에서 설명한 Member는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다.

```java
public class Member{    
	private Car myCar = new Lexus();//Car은 인터페이스, Lexus는 구현 클래스
}
```

**즉 DIP를 위반한것이다**

<br/>

<br/>

## 객체 지향 설계와 스프링

**객체 지향의 핵심은 다형성**이다. 

그러나 다형성 만으로는 **OCP, DIP를 지킬 수 없다.**

##### 이를 해결하기 위해 스프링이 등장하였고, 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.

- **DI(Dependency Injection): 의존관계, 의존성 주입**
- DI 컨테이너 제공

덕분에 우리는 **클라이언트 코드의 변경 없이 기능을 확장**할 수 있게 되었다.

<br/>

<br/>

### 📔 Reference

##### [인프런 - 스프링 핵심 원리 -기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard)

##### [🙈[Spring] 스프링 개론🐵](https://victorydntmd.tistory.com/158)
